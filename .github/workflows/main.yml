- name: Scrape LinkedIn Profile
        id: scrape_step
        run: |
          # Ensure output.log is created even if empty
          touch output.log
          node -e "
          const puppeteer = require('puppeteer');
          const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));
          (async () => {
            const browser = await puppeteer.launch({ headless: 'new', args: ['--no-sandbox', '--disable-setuid-sandbox'] });
            const page = await browser.newPage();
            await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36');
            await page.setExtraHTTPHeaders({
              'Accept-Language': 'en-US,en;q=0.9',
              'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8'
            });
            try {
              await page.goto('https://www.linkedin.com/in/satyanadella', { waitUntil: 'domcontentloaded', timeout: 60000 });
              await delay(2000);

              // Log initial page title and content for debugging
              console.log('Initial Page title:', await page.title());
              console.log('Initial Page content snippet:', await page.evaluate(() => document.body.innerHTML.substring(0, 500)));

              // Check for and dismiss the sign-in modal - Improved logic
              const dismissButtonSelector = 'button[data-tracking-control-name=\"public_profile_contextual-sign-in-modal_modal_dismiss\"]';
              try {
                await page.waitForSelector(dismissButtonSelector, { timeout: 10000 }); // Increased timeout
                console.log('Dismiss button found, clicking...');
                await page.click(dismissButtonSelector);
                await delay(5000); // Increased wait time after clicking
                console.log('Dismiss button clicked, waiting for profile to load...');
              } catch (error) {
                console.log('Dismiss button not found or click failed:', error.message);
              }

              // Log page title and content after modal dismissal attempt
              console.log('Page title after dismiss attempt:', await page.title());
              console.log('Page content snippet after dismiss attempt:', await page.evaluate(() => document.body.innerHTML.substring(0, 500)));

              // Scrape the name's CSS selector - More specific selectors
              let selector = 'Selector not found';
              const possibleSelectors = [
                'h1[class*="text-heading-xlarge"]', // More general selector
                'h1[class*="pv-top-card"]',      // Another common pattern
                '[data-test-id="profile-header-name"]' // Data attribute
              ];

              for (const sel of possibleSelectors) {
                try {
                  await page.waitForSelector(sel, { timeout: 5000 });
                  const nameElement = await page.$(sel);
                  if (nameElement) {
                    const className = await nameElement.evaluate(el => el.className);
                    selector = className.split(' ').map(cls => '.' + cls).join('');
                    console.log('Found name element with selector:', selector);
                    break; // Exit the loop once a selector is found
                  }
                } catch (error) {
                  console.log(`Selector '${sel}' not found:`, error.message);
                }
              }

              console.log('Latest selector:', selector);
              process.env.SELECTOR = selector;

            } catch (error) {
              console.error('Error during scraping:', error.message);
              process.env.SELECTOR = 'Failed to scrape - possible CAPTCHA or block: ' + error.message;
            } finally {
              await browser.close();
            }
          })();
          " >> output.log 2>&1
          # Extract selector and handle case where it might not be found
          SELECTOR_VALUE=$(cat output.log | grep 'Latest selector:' | sed 's/Latest selector: //')
          if [ -z "$SELECTOR_VALUE" ]; then
            echo "No selector found in output.log, checking for error"
            SELECTOR_VALUE=$(cat output.log | grep 'Error during scraping:' | sed 's/Error during scraping: //')
            if [ -z "$SELECTOR_VALUE" ]; then
              SELECTOR_VALUE="No data or error logged"
            fi
          fi
          # Sanitize SELECTOR_VALUE: remove spaces and special characters
          SANITIZED_SELECTOR=$(echo "$SELECTOR_VALUE" | tr -d '[:space:]' | sed 's/[^a-zA-Z0-9.-]/-/g')
          echo "SELECTOR=$SANITIZED_SELECTOR" >> $GITHUB_ENV
          echo "Debug: SELECTOR set to $SANITIZED_SELECTOR" >> output.log
